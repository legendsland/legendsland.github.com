---
layout: post
title: 图灵机（3）：合并动作
description: 
categories: [blog,cn]
---

    0010110111011110111110...

这个打印输出怎么样？由 0 间隔起来的，逐次增加的 1。如果你用高级编程语言做是容易的事情，比如 C:

{% highlight c %}
int ones = 0;
while(1) {
  int i = ones;
  printf("0");
  while(i) {
     printf("1");
     i--;
  }
  ones++;
}
{% endhighlight %}

两次循环，一次是循环打印 0 和 1，另一次循环打印多个 1。C 语言是对存储式计算机的抽象，最终的特征是它具有可读写的状态，比如上段程序中的变量 ones，用于保存当前循环需要打印的 1 的个数。这种状态变量能很好地模拟客观世界，因为客观世界中的物体在不同时刻也会拥有不同状态。

图灵机很简陋，没有这种记录状态的东西，它只能写下 0 或者 1，其实这样来看：状态 n 可以表示成为 n 的 0 或者 1，比如纸带上 n 个练习的 1 表示数字 n。图灵使用另外一个符号来标记状态，x。

<pre>
    0 * ə r 1
    1 * ə r 2
    2 * 0 r 3
    3 * * r 4
    4 * 0 l 5
    5 * * l 6

    6 1 * r 7
    7 * x l 8
    8 * * l 9
    9 * * l 6
    6 0 * * 11

    11 0 * r 12
    12 * * r 11
    11 1 * r 13
    13 * * r 11
    11 _ 1 l 14

    14 x _ r 11
    14 ə * r 16
    14 _ * l 15
    15 * * l 14

    16 * * r 17
    17 * * r 16
    16 _ 0 l 18
    18 * 0 l 6
</pre>

将上面代码复制到 http://morphett.info/turing/turing.html 就能看到图灵机实际的打印动作，即这段程序的实际含义。基本上，可以说这是世界上可读性极差的代码，没有注释，使用没有任何含义的数字命名。这也是图灵机的限制之一，它出于最简机器的设计，不会提供核心能力之外的任何其他功能。在图灵的论文中，他可不想将代码都写成这样，他也是为了分析和论证的方便，将中间状态合并了：将多个操作压缩在一个指令中。比如上段代码中的：

<pre>
    0 * ə r 1   ;打印ə，右移
    1 * ə r 2   ;打印ə，右移
    2 * 0 r 3   ;打印0，右移
    3 * * r 4   ;右移
    4 * 0 l 5   ;打印0，左移
    5 * * l 6   ;左移，进入状态 6
</pre>

其实 1-5 都是中间状态，它们的第二个参数都是 \*，可以合并写成：

    0 * ərər0rr0ll 6

图灵的论文表示如下：

{:.post-img}
![](/assets/images/01table.png)

翻译成支持多动作的程序就是：

<pre>
    0 * ərər0rr0ll 6

    6 1 rxlll 6
    6 0 * 11

    11 0 rr 11
    11 1 rr 11
    11 _ 1l 14

    14 x _r 11
    14 ə r 16
    14 _ ll 14

    16 * rr 16
    16 _ 0ll 6
</pre>


这似乎让我们看到了图灵机的希望：它居然能模拟一段 C 程序运行，事实上，它们模拟所有的高级语言！这得到这个结论之前，图灵需要寻找一种更简单地编写指令的方法 —— 子程序。


---
layout: post
title: 编程到底难在哪里？
description: 对比写作又如何
categories: [blog,cn]
---

若以写作相比，编程的困难在于代码的含义是“易失的”、“模糊的”。

作家在构思文章（小到随笔，大到长篇）的时候，他使用自然语言作为书写的工具，他能很好的记住自己写了什么，并知道自己想写出什么（长篇有些例外的情况，就是作者一边写一边想）。文字记忆对他们是非常牢靠的，随便一撇就知道3个月前写得一段话，当初想表达什么意思，但编程做不到，或者说很难做到。往往程序编到一定的行数，就迷失了，迷失在自己修筑的迷宫之中。

其次，通常意义的写作是一个人的行为，而大多数时候的编程是多个人不同时段的协作行为，这让事情变得更加复杂和难以达成共识。你的老板和客户有他们的期望，同事有各种不同的看法和做法，所有这些因素叠加在一起，使编程变成一种混乱，频临失控边缘的一种后现代艺术 —— 没人真正完全懂这些代码到底是什么意思。

至于你提到的算法，以及用人脑去思考电脑的问题，确实是一大因素，因为程序要求正确性，从理论上将无法通过另一个程序去保证，（目前）只能用人脑去验证，就像自动化流水线诞生前，工厂产线上的工人要用眼和手去生产、装配一样，这是庞杂繁重却无法替代的工作。程序好像是拥有巨多变量的一个方程，只要一个变量设置不对，结果就不对，人脑对这种事情显然是很不擅长的。所以说，软件产品天生的复杂性决定了编程对人而言是一件困难的事情。

以上两点都是让编程困难的因素，是人脑力有限导致的。

在《人月神话》中作者提出了软件的复杂在于两点：

1. 本质复杂的 - 编程活动本身的性质和目标决定了编程很难
2. 偶然复杂的 - 各种复杂的外界因素，比如开发工具、不靠谱的需求变动、糟糕的开发管理模式、人员变动等等让编程变得更难

如果你了解图灵机就知道，前辈们在纸带上求 sqrt(2) 是一件多么困难的事情！要无数次的左右移动，这种困难是偶然困难，因为现代化的编程语言，比如 C，使用牛顿迭代算法求 sqrt(2) 几行就够了。sqrt(2) 的本质困难取决于它迭代算法收敛的速度 —— 这居然变成了数学问题。

有次我问一同事，他们服务器怎么支撑大并发量请求的，有牛逼的算法没有？他很简单地说：加服务器。这是一个避开了本质困难，解决偶然困难的经典案例。

在编程生涯中大多数精力将花在与偶然复杂搏斗上面，而那些真正本质复杂的问题，重要却少有人关心 —— 这也是让编程变得更加困难的一个原因。


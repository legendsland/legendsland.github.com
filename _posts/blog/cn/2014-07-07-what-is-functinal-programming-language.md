---
layout: post
title: 什么是函数式语言？
description: 一个通俗而彻底的解释
categories: [blog,cn]
---

在第一堂关于编程的课上，老师就会说，将数据传入函数，然后产生结果：

data => function => result，类似于这样的程序：

{% highlight bash %}
function add(a, b)
  return a+b;
end
{% endhighlight %}

可以表示成为： function (data) => data，指函数接受数据，处理，最后输出数据作为计算结果。

这种占据大部分人脑袋的观点直接导致了函数和数据的分割，认为两者是完全不同的东西，然后才有 “函数式语言” 的这种说法。因为在函数式的语言里面，程序和数据用样都是函数。

在任何程序语言还没有发明之前，在计算机科学家的草稿纸上，都是直接用一种叫做 lambda 函数 的东西来计算的。这些奇怪的函数重新（彻底地）定义了数和数据！就是说最简单的数据，比如正整数，1,2,3,4.. 这些东西都可以表示成为 lambda 函数。

所有的程序都是类似这样的东西：

function(function) => function，指函数接受另一个函数作为参数，运算，最后再输出一个函数作为计算结果。那个世界里根本就没有数或者对象这种概念，全是函数。可是，这怎么可能？

这的确是一个颠覆性的概念。他们用计算的过程（动作）代替了实体（概念）。比如 3 这个概念，从实体来看，它可能是 3 个苹果，或者内存中的几个0和1，从过程的角度来看，它可能是调用了某个函数 3 次，至于结果是什么，一点都不重要，重要的是调用了 3 次，调用这个动作做了 3 次。

你看，3 其实是一个很复杂的东西。函数式语言，从一开始就采取了与我们看待这个世界完全不同的世界观。这也是使用对象语言久了之后，难以接受函数语言的原因。万物皆是对象，很好理解，而万物皆是函数，确实难以理解。

比如在 scheme （一种函数式语言），你可以这样定义整数：

{% highlight scheme %}
;; 定义数字： 1
(define (one a)
 (lambda (b)
  (a b)))
{% endhighlight %}

用 javascript （你也可以把它当作函数式语言）就是这样：
{% highlight javascript %}
function one (a) {
  return function (b) {
    return a(b);
  }
}
{% endhighlight %}

数字1 是一个函数，它接受另一个函数 a 作为参数，然后返回一个函数，这个返回的函数带一个参数 b，函数体里面会调用 a(b)，并返回结果。

这就是函数式语言里面最原始的数字1。如果你在此的基础上能定义出一个后续函数 succ，那么，succ (1) 自然就是2了，这个后续函数还真的存在：

{% highlight scheme %}
;; 后续函数
(define (succ a)
 (lambda (b)
  (lambda (c)
   (b ((a b) c)))))
{% endhighlight %}

用 javascript 就是这样：
{% highlight javascript %}
function succ (a) {
  return function (b) {
    return function(c) {
      return b( a(b)(c) );
   }
 }
}
{% endhighlight %}


那么 2 的定义使用后续函数就会是：
{% highlight scheme %}
(define (two a)
 (lambda (b)
  (((succ one) a) b)))
{% endhighlight %}

用 javascript 就是这样：
{% highlight javascript %}
function two(a) {
  return function (b) {
     return succ(one)(a)(b);
  }
}
{% endhighlight %}

当你用函数重新把这些基础的东西，比如‘数’，以及更高级的数据结构定义一遍后，会发现，各种用非函数式语言下的算法、程序都可以用这一套实现，可以有些地方还能做得更好。

不过看起来是不是好恶心？简单的几个数字怎么复杂？因为这些最开始是数学家们的玩意，他们用这一套函数去证明一些结论。编程语言说到底是机械的、基于固定规则的、毫无内涵的符号替换。对象型语言来自最原始的图灵机模型（读、写、跳转这样操作），而函数式语言来自 Lambda 函数（符号替换、规约等操作），本质上它们是完全等价的。但是对编程而言，思维上有较大的差异。最早的语言比如 C 和 lisp 分别是这两类的代表，毫无共性可言，而更现代的语言，比如 python, javascript 它们吸收了这两派的优点，使得编程风格更混合了。

当对象之间有清晰的界限的时候，对象型语言更擅长处理，而边界模糊的时候，函数型更擅长。就像经典力学擅长处理边界清晰宏观世界，而量子力学擅长处理边界模糊的微观世界一样。

注：

这个说法来自 SICP (计算机程序的构造和解释) 的第三章结尾：3.5.5 函数式程序的模块化和对象的模块化:

> 本章开始时提出了一个目标，那就是构造出一些计算模型，使其结构能够符合我们对于试图去摸拟的真实世界的看法。我们可以将这一世界模拟为一集相互分离的、 受时间约束的、具有状态的相互交流的对象，或者可以将它模拟为单一的、 无时间也无状态的统一体。每种观点郁有其强有力的优势。但就其自身而言，又没有一种方式能够完全令人满意。我们还在等待着一个大统一的出现[1]。

> [1] 对象模型对世界的近似在于将其分割为独立的片断，函数式模型则不是沿着对象间的边界去做模块化。当“对象"之间不共享的状态远远大于它们所共享的状态时，对象模型就特别好用。这种对象观点失效的一个地方就是量子力学。在那里，将物体着作独立的粒子就会导致悖论和混乱。将对象观点与函数式观点合并可能与程序设计的关系不大，而是与基本认识论有关的论题 。

简单来讲，当你用程序对日常生活的用品，比如桌子、板凳建立计算模型的时候，用创建对象的方式是自然而然的想法，因为它们的根本属性是相对独立的。但如果引入现实中的时间概念 —— 这是无法避免的，除非人类明白时间的真实含义 —— 事情有了先后顺序，对象之间有了基于时间的依赖关系：时间的引入导致了并发的执行过程，告诉我，除了众所周知的锁，你有更好的解决方法吗？

SICP 里面介绍了一种 stream 技术，将时间“消掉”了，就像我们解方程的时候，幸喜地发现某个未知变量居然能够在等式两边消去！但这种技术并不是终极解决方法，对时间并发性本质上的难度无能为力。



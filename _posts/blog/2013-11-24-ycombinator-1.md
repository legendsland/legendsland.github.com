---
layout: post
title: Y Combinator （Part 1 简介）
category: blog
---


如果你对λ有所了解，那么一定对这个表达印象深刻：

    λx.(x x)(λx.(x x))

当试图计算的时候，将参数带入函数内部会得到它自己：

    λx.(x x)(λx.(x x))
  
λ的运算规则决定了这样“奇怪”的东西，它将永远计算下去，永远得到自己。如果将这个表达式用函数 f 复合一次，并将 (x x) 应用到 f：

    λf.λx.f(x x)(λx.f(x x))

将它命名为Y。当我们传入函数 F 计算的时候：

<pre>
    YF = (λf.(λx.f(x x))(λx.f(x x))) F
    =>    (λx.F(x x)) (λx.F(x x))
    =>    F( (λx.F(x x)) (λx.F(x x) )
    =>    F(YF)
</pre>

我不清楚最开始 Y 是怎么想出来的，但以上的思考是完全直觉的，从一个最简单“无穷循环” 的 λx.(x x)(λx.(x x)) 经过一次简单的复合形成的 Y。你看，Y 也并非像是冥思苦想的结果，可能就是一次无意中的尝试而得到的美妙结果。

和 λx.(x x)(λx.(x x)) 一样，(x x) 的结构决定了运算过程可以无穷下去，唯一的区别是 Y 多了了一个函数 f，f 的运算结果决定了这个无穷的过程是否会终止。比如在某一步 F(F(F(....F(YF))，最里面的 F(YF)的计算，F 发现完全不需要理会 YF 这个参数了，可以直接算出结果，于是整个无穷的过程便会终止，接着再计算出来，最终得出结果。并非有所的 F 都具备这种终结的性质，数学上证明了，递归函数具备这种特性。

将递归函数的无穷性便转移到 Y 上面，使递归函数仅保留最核心的定义，这一点正是 Y 的强大之处：不仅让递归函数可以用 λ 去定义，而且在我看来，（更重要的），这是重构函数的一个超级高端的方法 —— 将描述与循环的过程分离了。

以 factorial 为例，它的 scheme 描述就是：

<?prettify lang=scm?> <pre class="prettyprint">
    (lambda (n)
      (if (= n 0) 1
          (* n (???  (- n 1)))))
</pre>

里面的 ??? ，可以一直这样扩展下去：

<?prettify lang=scm?> <pre class="prettyprint">
    (lambda (n)
      (if (= n 0) 1
          (* n ((lambda (n)
                    (if (= n 0) 1
                        (* n (???  (- n 1)))))
      (- n 1)))))
    ...
</pre>

但如果存在一个函数 g ，等价于 ???，那么就能代替这种无穷过程，factorial 就可以写成：

<?prettify lang=scm?> <pre class="prettyprint">
    (lambda (g)
     (lambda (n)
       (if (= n 0) 1
         (* n (g  (- n 1))))))
</pre>

当然，这是我们最良好的愿望，factorial 如果能表达成这种形式，简直就是编程上的完美，它简要地概括了 factorial 定义的精髓，而且没有无穷的循环，唯一的问题是这个 g 悬挂在哪里，这个 g 到底是什么？有几点可以假设一下：

1. g 应该是通用的，因为不通用的部分，已经写在了 factorial 里面了。
2. g 既然是通用的，g 更多地是承载了某种形式上无穷循环，把无穷抽象出来成了一台机器，一个过程（比如 factorial）丢到里面，它就能制造出递归运算的过程。

寻找 g 的过程并非那么直接，而且你如果总是考虑这个 g 的 lambda 表达式到底是什么，估计永远也找不到了。回到 Y：
λf.λx.f(x x)(λx.f(x x))

当将 F 作为参数应用到 Y 上面的时候，会得到 F( ... ) 这样的表达式，F “自然会找到”它的参数。这就是说 g 不一定要显式地存在，当我们把 factorial 作为参数传递给某个函数的时候，可能就无须寻找 g 的 lambda 表达式了。于是，将 factorial 应用到 Y：

(Y facorial)  根据 YF = F(YF) 的特性：

<?prettify lang=scm?> <pre class="prettyprint">
    =>
    facorial (Y facorial) 
    =>
    ((lambda (g)
     (lambda (n)
       (if (= n 0) 1
         (* n (g  (- n 1))))))
    (Y facorial ))  
    =>
    (lambda (n)
       (if (= n 0) 1
         (* n ((Y facorial )  (- n 1))))))
</pre>

这是新得到的 lambda，这个 lambda 是可以直接计算出结果的 —— 当参数 n = 0 时！如果 n>0 ，每次计算都会使得 n-1，直到 n=0 为止，所以这个过程会终止。这得益于 if，if 先计算它的条件，如果成立则计算成立情况下的结果，根本就不管不成功下的结果了，这样就使得整个表达式能够返回。Y 完美地抽象出了 factorial 的递归过程。

这当然是 lambda calculus 的成功，Church 用它成功地定义了递归函数。但在我看来，它的这种秩序和对称美，抽出了递归结构的精髓，将一个递归函数的运算规则和运算过程分离开来，这不仅是理论上的游戏，一种编程上的高端手法，更体现了抽象和组合的深刻内涵：自相似的无穷结构竟然都能抽象出来，并和其他部分组合起来运算（但这个抽象太基础太重要了，因为每种现代语言里面都自带该功能）。

这便是 Y —— 像不像无限分叉下去的一个叉子，把无限分叉下去的一个叉子，给叉出来了。



